from assess.prototypes.simpleprototypes import Tree
from assess.algorithms.signatures.signatures import Signature

from gnmutils.objectcache import ObjectCache


class TreeDistanceAlgorithm(object):
    def __init__(self, signature=Signature()):
        self._signature = signature
        self._prototypes = []

        self._tree = Tree()
        self._tree_dict = ObjectCache()

    @property
    def prototypes(self):
        return self._prototypes

    @prototypes.setter
    def prototypes(self, value=None):
        self._prototypes = value

    def node_counts(self, original=False):
        """
        Returns the count of nodes for monitoring tree. If original is true, then the node counts of
        the original tree are returned, otherwise the count generated by signature is used.
        :param original: True, if the count is based on tree, false otherwise
        :return: The count of nodes used for monitoring tree (either for tree or based on signatures)
        """
        count = self._tree.node_count()
        return [count for i in range(len(self._prototypes))]

    def prototype_counts(self, original=False):
        """
        Returns the counts of the prototyes trees. If original is true, then the node counts of the
        original prototype trees are returned, otherwise the count generated by signature is used.
        :param original: true, if the count is based on tree, false otherwise
        :return: The count of nodes used for prototype trees (either for tree or based on signatures)
        """
        return [self.node_count_for_prototype(prototype, original=original) for prototype in self._prototypes]

    def node_count_for_prototype(self, prototype, original=False):
        return prototype.node_count()

    def prototypes_converted_for_algorithm(self):
        return self._prototypes

    def start_tree(self):
        self._tree = Tree()
        self._tree_dict = ObjectCache()

    def finish_tree(self):
        pass

    def add_events(self, eventgenerator, **kwargs):
        for event in eventgenerator:
            result = self.add_event(event, **kwargs)
        return result

    def add_event(self, event, **kwargs):
        return self._add_event(event, **kwargs)

    def _add_event(self, event, **kwargs):
        raise NotImplementedError

    def _create_node(self, event, **kwargs):
        parent = self._tree_dict.getObject(tme=event.tme, pid=event.ppid)
        # TODO: I might directly add this to node, but therefore I need to ensure to use pid, ppid
        node = self._tree.add_node(
            event.name,
            parent=parent,
            tme=event.tme,
            pid=event.pid,
            ppid=event.ppid
        )
        signature = self._signature.get_signature(node, parent)
        self._tree_dict.addObject(node, pid=event.pid, tme=event.tme)
        return signature

    def _update_distances(self, **kwargs):
        raise NotImplementedError

    def __repr__(self):
        return self.__class__.__name__
